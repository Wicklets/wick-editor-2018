<!-- This is the "empty" wick player - it doesn't do anything 
     unless the editor bundles a project inside of it.  -->

<head>
    <title>Wick Player</title>

    <style>
        /* remove the top and left whitespace */
    	* { margin:0; padding:0; }

        /* just to be sure these are full screen */
    	html, body { width:100%; height:100%; }

        /* To remove the scrollbars */
    	canvas { display:block; }
    </style>
</head>

<body>
	<div id="playerCanvasContainer">
		<canvas id="playerCanvas"></canvas>
	</div>
</body>


<script>// Framerate keeper 
// http://www.html5gamedevs.com/topic/1828-how-to-calculate-fps-in-plain-javascript/
var fps = { startTime : 0,
	frameNumber : 0,
	getFPS : function() {
		this.frameNumber++;

		var d = new Date().getTime();
		var currentTime = ( d - this.startTime ) / 1000;
		var result = Math.floor( ( this.frameNumber / currentTime ) );

		if( currentTime > 1 ) {
			this.startTime = new Date().getTime();
			this.frameNumber = 0;
		}

		return result;
	}   
};</script>
<script>var VerboseLog = (function () {

	var verboseLog = { };

	verboseLog.verbose = true;

	verboseLog.log = function (str) {
		if(verboseLog.verbose) {
			console.log(str);
		}
	}

	verboseLog.error = function (str) {
		if(verboseLog.verbose) {
			console.error(str);
		}
	}

	verboseLog.log("Verbose console is enabled. Turn it off in verboselog.js if you want.")

	return verboseLog;

})();</script>
<script> var BrowserDetectionUtils = (function () {

	var browserDetectionUtils = { };

	browserDetectionUtils.isSafari = 
	    navigator.appVersion.search('Safari') != -1 
	 && navigator.appVersion.search('Chrome') == -1 
	 && navigator.appVersion.search('CrMo') == -1 
	 && navigator.appVersion.search('CriOS') == -1;

	browserDetectionUtils.isIe = (
	    navigator.userAgent.toLowerCase().indexOf("msie") != -1 
	 || navigator.userAgent.toLowerCase().indexOf("trident") != -1 );

	browserDetectionUtils.inMobileMode =
		/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

	return browserDetectionUtils;
	
})();</script>
<script>/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
var Base64ArrayBuffer = (function () {
  "use strict";

  var base64ArrayBuffer = { };

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  base64ArrayBuffer.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  base64ArrayBuffer.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };

  return base64ArrayBuffer;

})();
</script>
<script>/* Util functions that both the player and the editor need */

var WickSharedUtils = (function () {

	var wickSharedUtils = { };

	/* Call callback function for every child object in parentObj */
	wickSharedUtils.forEachChildObject = function (parentObj, callback) {
		for(var f = 0; f < parentObj.frames.length; f++) {
			for(var o = 0; o < parentObj.frames[f].wickObjects.length; o++) {
				callback(parentObj.frames[f].wickObjects[o]);
			}
		}
	}

	/* Call callback function for every child object in parentObj's current frame */
	wickSharedUtils.forEachActiveChildObject = function (parentObj, callback) {
		var currFrame = parentObj.currentFrame;
		for(var o = 0; o < parentObj.frames[currFrame].wickObjects.length; o++) {
			callback(parentObj.frames[currFrame].wickObjects[o]);
		}
	}

	/* Call callback function for every child object in parentObj's first frame */
	wickSharedUtils.forEachFirstFrameChildObject = function (parentObj, callback) {
		for(var o = 0; o < parentObj.frames[0].wickObjects.length; o++) {
			callback(parentObj.frames[0].wickObjects[o]);
		}
	}

	/* */
	var encodeString = function (str) {
		var newStr = str;
		newStr = encodeURI(str);
		newStr = newStr.replace(/'/g, "%27");
		return newStr;
	}

	/* */
	var decodeString = function (str) {
		var newStr = str;
		newStr = newStr.replace(/%27/g, "'");
		newStr = decodeURI(str);
		return newStr;
	}

	/* Encodes scripts to avoid JSON format problems */
	wickSharedUtils.encodeScripts = function (wickObj) {

		if(wickObj.wickScripts) {
			for (var key in wickObj.wickScripts) {
				wickObj.wickScripts[key] = encodeString(wickObj.wickScripts[key]);
			}
		}

		if(wickObj.fontData) {
			wickObj.fontData.text = encodeString(wickObj.fontData.text);
		}

		if(wickObj.isSymbol) {
			wickSharedUtils.forEachChildObject(wickObj, function(currObj) {
				wickSharedUtils.encodeScripts(currObj);
			});
		}

	}

	/* Decodes scripts back to human-readble and eval()-able format */
	wickSharedUtils.decodeScripts = function (wickObj) {
		
		if(wickObj.wickScripts) {
			for (var key in wickObj.wickScripts) {
				wickObj.wickScripts[key] = decodeString(wickObj.wickScripts[key])
			}
		}

		if(wickObj.fontData) {
			wickObj.fontData.text = decodeString(wickObj.fontData.text);
		}

		if(wickObj.isSymbol) {
			wickSharedUtils.forEachChildObject(wickObj, function(currObj) {
				wickSharedUtils.decodeScripts(currObj);
			});
		}

	}

	return wickSharedUtils;

})();</script>
<script>var WickPlayer = (function () {

	var wickPlayer = { };

	// Current project being played by player
	var project;

	// Input vars for mouse and (later) keyboard and accelerometer
	var mouse;
	var keys;

	// Canvas stuff (To be replaced with three/webgl/pixi)
	var canvas;
	var context;
	var canvasContainerEl;

	// Screen fitting vars
	var projectFitScreenScale;
	var projectFitScreenTranslate;
	var widthRatio;
	var heightRatio;

	// Audio stuff
	var audioContext;
	var readyToStartWebAudioContext;

	// Flags for different player modes (phone or desktop)
	var mobileMode;
	var desktopMode;

	// Set this to true to stop the next requestAnimationFrame
	var stopDrawLoop;

/*****************************
	Player Setup
*****************************/

	wickPlayer.runProject = function(projectJSON) {

		stopDrawLoop = false;

		// Setup canvas
		canvas = document.getElementById("playerCanvas");
		context = canvas.getContext('2d');
		canvasContainerEl = document.getElementById("playerCanvasContainer");

		projectFitScreenScale = 1.0;
		projectFitScreenTranslate = {x : 0, y : 0};

		// Check if we're on a mobile device or not
		mobileMode = BrowserDetectionUtils.inMobileMode;
		desktopMode = !mobileMode;

		// Setup WebAudio context
		if(!mobileMode) {
			setupWebAudioContext();
		}

		// Setup mouse and key events (desktop mode)
		mouse = { x : 0, y : 0 };
		keys = [];
		if(desktopMode) {
			canvas.addEventListener('mousemove', onMouseMove, false);
			canvasContainerEl.addEventListener("mousedown", onMouseDown, false);

			document.body.addEventListener("keydown", handleKeyDownInput);
			document.body.addEventListener("keyup", handleKeyUpInput);
		}

		// Setup touch events (mobile mode)
		if(mobileMode) {
			// Touch event (one touch = like a mouse click)
			canvasContainerEl.addEventListener("touchstart", onTouchStart, false);

			// Squash gesture events
			canvasContainerEl.addEventListener('gesturestart', function(e) {  e.preventDefault(); });
			canvasContainerEl.addEventListener('gesturechange', function(e) {  e.preventDefault(); });
			canvasContainerEl.addEventListener('gestureend', function(e) {  e.preventDefault(); });
		}

		// update canvas size on window resize
		window.addEventListener('resize', resizeCanvas, false);

		// Load the project!
		loadJSONProject(projectJSON);
		resizeCanvas();

	}

	wickPlayer.stopRunningCurrentProject = function() {

		stopDrawLoop = true;

		canvasContainerEl.removeEventListener("mousedown", onMouseDown);
		canvasContainerEl.removeEventListener("touchstart", onTouchStart);

		document.body.removeEventListener("keydown", handleKeyDownInput);
		document.body.removeEventListener("keyup", handleKeyUpInput);

		window.removeEventListener('resize', resizeCanvas);

		audioContext.close();

	}

/*****************************
	WebAudio Context
*****************************/

	var setupWebAudioContext = function () {
		var AudioContext = window.AudioContext // Default
						|| window.webkitAudioContext // Safari and old versions of Chrome
						|| false;
		audioContext = new AudioContext();

		if(!audioContext) {
			alert("WebAudio not supported! Sounds will not play.");
			return;
		}

		// Setup dummy node and discard it to get webaudio context running
		if(audioContext.createGainNode) {
			audioContext.createGainNode();
		} else {
			audioContext.createGain();
		}
	}

	var playSound = function (rawBuffer) {
		VerboseLog.log("now playing a sound, that starts with", new Uint8Array(rawBuffer.slice(0, 10))[0]);
		audioContext.decodeAudioData(rawBuffer, function (buffer) {
		    if (!buffer) {
		        VerboseLog.error("failed to decode:", "buffer null");
		        return;
		    }
		    var source = audioContext.createBufferSource();
		    source.buffer = buffer;
		    source.connect(audioContext.destination);
		    source.start(0);
		    VerboseLog.log("started...");
		}, function (error) {
		    VerboseLog.error("failed to decode:", error);
		});
	}

/*****************************
	Opening projects
*****************************/

	var loadJSONProject = function (proj) {
		// Parse dat project
		project = JSON.parse(proj);

		VerboseLog.log("Player loading project:")
		VerboseLog.log(project);

		// Prepare all objects for playing
		WickSharedUtils.decodeScripts(project.rootObject);
		resetAllPlayheads(project.rootObject);
		resetAllEventStates(project.rootObject);
		generateObjectNameReferences(project.rootObject);
		generateObjectParentReferences(project.rootObject);
		generateBuiltinWickFunctions(project.rootObject);
		generateHTMLSnippetDivs(project.rootObject);
		loadImages(project.rootObject);
		if(!mobileMode) {
			loadAudio(project.rootObject);
		}

		// Start draw/update loop
		draw();
		animate();
	}

	/* Create variables inside each wickobject so we can say root.bogoObject.play(); and such */
	var generateObjectNameReferences = function (wickObj) {
		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			wickObj[subObj.name] = subObj;

			if(subObj.isSymbol) {
				generateObjectNameReferences(subObj);
			}
		});
	}

	/* We'll need these when evaling scripts */
	var generateObjectParentReferences = function (wickObj) {
		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			subObj.parentObj = wickObj;
			if(subObj.isSymbol) {
				generateObjectParentReferences(subObj);
			}
		});
	}

	/* */
	var generateBuiltinWickFunctions = function (wickObj) {

		wickObj.hitTest = function (otherObj) {

			if(!otherObj) {
				console.error('hitTest with invalid object as param!!')
			}

			// TODO: Use proper rectangle collision
			var wickObjCentroid = {
				x : wickObj.left + wickObj.width*wickObj.scaleX/2,
				y : wickObj.top + wickObj.height*wickObj.scaleY/2
			};
			return pointInsideObj(otherObj, wickObjCentroid);
		}

		if(wickObj.isSymbol) {
			// Setup builtin wick scripting methods and objects
			wickObj.play = function (frame) {
				wickObj.isPlaying = true;

				wickObj.currentFrame ++;
				if(wickObj.currentFrame == wickObj.frames.length) {
					wickObj.currentFrame = 0;
				}
			}
			wickObj.stop = function (frame) {
				wickObj.isPlaying = false;
			}
			wickObj.gotoAndPlay = function (frame) {
				wickObj.isPlaying = true;
				wickObj.currentFrame = frame;
			}
			wickObj.gotoAndStop = function (frame) {
				wickObj.isPlaying = false;
				wickObj.currentFrame = frame;
			}
			wickObj.gotoNextFrame = function () {
				wickObj.currentFrame ++;
				if(wickObj.currentFrame >= wickObj.frames.length) {
					wickObj.currentFrame = wickObj.frames.length-1;
				}
			}
			wickObj.gotoPrevFrame = function () {
				wickObj.currentFrame --;
				if(wickObj.currentFrame < 0) {
					wickObj.currentFrame = 0;
				}
			}

			WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
				generateBuiltinWickFunctions(subObj);
			});
		}
	}

	/* */
	var generateHTMLSnippetDivs = function (wickObj) {

		if (wickObj.htmlData) {
			var snippetDiv = document.createElement("div");
			snippetDiv.style.position = 'fixed';
			snippetDiv.style.width = '600px';
			snippetDiv.style.height = '600px';
			snippetDiv.style.top = wickObj.top + 'px';
			snippetDiv.style.left = wickObj.left + 'px';
			snippetDiv.innerHTML = wickObj.htmlData;
			document.getElementById('playerCanvasContainer').appendChild(snippetDiv);
		}

		if(wickObj.isSymbol) {
			WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
				generateHTMLSnippetDivs(subObj);
			});
		}

	}

	/* Make sure all objects start at first frame and start playing */
	var resetAllPlayheads = function (wickObj) {

		// Set this object to it's first frame
		wickObj.currentFrame = 0;

		// Stop this object
		// (Note: objects should probably be playing instead of stopped initially)
		wickObj.isPlaying = true;

		// Set this object to need its onLoad script run
		wickObj.onLoadScriptRan = false;

		// Recursively set all timelines to first frame as well
		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			if(subObj.isSymbol) {
				resetAllPlayheads(subObj);
			}
		});

	}

	/* */
	var resetAllEventStates = function (wickObj) {

		// Reset the mouse hovered over state flag
		wickObj.hoveredOver = false;

		// Do the same for all this object's children
		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			if(subObj.isSymbol) {
				resetAllEventStates(subObj);
			}
		});

	}

	/* Recursively load images of wickObj */
	var loadImages = function (wickObj) {

		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			if(subObj.isSymbol) {
				loadImages(subObj);
			} else if(subObj.imageData) {
				subObj.image = new Image();
				subObj.image.src = subObj.imageData;
				subObj.image.onload = function() {
					// Scope issue - fix this, we need it for preloaders
					//subObj.imageIsLoaded = true;
				};
			}
		});
	}

	/* Recursively load audio of wickObj */
	var loadAudio = function (wickObj) {
		WickSharedUtils.forEachChildObject(wickObj, function(subObj) {
			if(subObj.isSymbol) {
				loadAudio(subObj);
			} else if(subObj.audioData) {
				var rawData = subObj.audioData.split(",")[1]; // cut off extra filetype/etc data
				var rawBuffer = Base64ArrayBuffer.decode(rawData);
				subObj.audioBuffer = rawBuffer;
			}
		});
	}

/*****************************
	Common event functions
*****************************/

	var resizeCanvas = function () {

		// Update canvas size
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		if(project && project.fitScreen) {
			// Calculate how much the project would have to scale to fit either dimension
			widthRatio = window.innerWidth / project.resolution.x;
			heightRatio = window.innerHeight / project.resolution.y;

			// Fit only so much that stuff doesn't get cut off
			if(widthRatio > heightRatio) {
				projectFitScreenScale = heightRatio;
			} else {
				projectFitScreenScale = widthRatio;
			}

			if(widthRatio > heightRatio) {
				projectFitScreenTranslate = {x : window.innerWidth / 2 - project.resolution.x * projectFitScreenScale / 2, y : 0};
			} else {
				projectFitScreenTranslate = {x : 0, y : window.innerHeight / 2 - project.resolution.y * projectFitScreenScale / 2 };
			}
		} else {
			projectFitScreenScale = 1.0;
			projectFitScreenTranslate = {x : 0, y : 0};
		}

	}

/*****************************
	Desktop event functions
*****************************/

	var onMouseMove = function (evt) {

		mouse = getMousePos(canvas, evt);

		// Check if we're hovered over a clickable object...
		var hoveredOverObj = false;
		WickSharedUtils.forEachActiveChildObject(project.rootObject, function(currObj) {
			if(pointInsideObj(currObj, mouse) && wickObjectIsClickable(currObj)) {
				currObj.hoveredOver = true;
				hoveredOverObj = true;
			} else {
				currObj.hoveredOver = false;
			}
		});

		//...and change the cursor if we are
		if(hoveredOverObj) {
			canvasContainerEl.style.cursor = "pointer";
		} else {
			canvasContainerEl.style.cursor = "default";
		}

	}

	var onMouseDown = function (evt) {
		
		WickSharedUtils.forEachActiveChildObject(project.rootObject, function(currObj) {
			if(pointInsideObj(currObj, mouse) && wickObjectIsClickable(currObj)) {
				runOnClickScript(currObj);
			}
		});

	}

	var handleKeyDownInput = function (event) {
		keys[event.keyCode] = true;

		WickSharedUtils.forEachActiveChildObject(project.rootObject, function(currObj) {
			runKeyDownScript(currObj);
		});
	}

	var handleKeyUpInput = function (event) {
		keys[event.keyCode] = false;
	}

/*****************************
	Mobile event functions
*****************************/

	var onTouchStart = function (evt) {

		evt.preventDefault();

		// on iOS, WebAudio context only gets 'unmuted' after first user interaction
		if(!audioContext) {
			setupWebAudioContext();
			loadAudio(project.rootObject);
		}

		var touchPos = getTouchPos(canvas, evt);

		WickSharedUtils.forEachActiveChildObject(project.rootObject, function(currObj) {
			if(pointInsideObj(currObj, touchPos) && wickObjectIsClickable(currObj)) {
				runOnClickScript(currObj);
			}
		});

	}

/*****************************
	Page/DOM Utils
*****************************/

	var getMousePos = function (canvas, evt) {
		var rect = canvas.getBoundingClientRect();

		var centeredCanvasOffsetX = (window.innerWidth - project.resolution.x) / 2;
		var centeredCanvasOffsetY = (window.innerHeight - project.resolution.y) / 2;

		return {
			x: evt.clientX - rect.left - centeredCanvasOffsetX,
			y: evt.clientY - rect.top  - centeredCanvasOffsetY
		};
	}

	var getTouchPos = function (canvas, evt) {
		var rect = canvas.getBoundingClientRect();
		var touch = evt.targetTouches[0];
		return {
			x: touch.pageX,
			y: touch.pageY
		};
	}

/*****************************
	WickObject Utils
*****************************/

	/*  */
	var pointInsideObj = function(obj, point) {

		if(obj.isSymbol) {

			var pointInsideSymbol = false;

			WickSharedUtils.forEachActiveChildObject(obj, function (currObj) {
				var subPoint = {
					x : point.x - obj.left,
					y : point.y - obj.top
				};
				if(pointInsideObj(currObj, subPoint)) {
					pointInsideSymbol = true;
				}
			});

			return pointInsideSymbol;

		} else {

			var scaledObjLeft = obj.left;
			var scaledObjTop = obj.top;
			var scaledObjWidth = obj.width*obj.scaleX;
			var scaledObjHeight = obj.height*obj.scaleY;

			return point.x >= scaledObjLeft && 
				   point.y >= scaledObjTop  &&
				   point.x <= scaledObjLeft + scaledObjWidth && 
				   point.y <= scaledObjTop  + scaledObjHeight;

		}
	}

	var wickObjectIsClickable = function (wickObj) {
		return wickObj.wickScripts['onClick'];
	}

/*****************************
	Draw/update loop
*****************************/

	var animate = function () {

		setTimeout(function() {
			if(!stopDrawLoop) {
				requestAnimationFrame(animate);
				update();
				draw();
			}
		}, 1000 / project.framerate);

	}

/*****************************
	Update/run scripts
*****************************/

	var update = function () {
		
		updateObj(project.rootObject);

	}

	var updateObj = function (obj) {

		// Run obj's onLoad if necessary, then all subObj's
		runOnLoadScript(obj);

		// Run obj's update if necessary, then all subObj's
		runUpdateScript(obj);

		// Advance obj's timeline one frame, then subobj's timelines
		advanceTimeline(obj);

	}

	var runOnLoadScript = function (obj) {

		if(!obj.onLoadScriptRan) {

			// Check for breakpoint
			if(obj.isSymbol && obj.frames[obj.currentFrame].breakpoint) {
				obj.isPlaying = false;
			}

			// Run onLoad script
			if(obj && !obj.isRoot && obj.wickScripts) {
				evalScript(obj, obj.wickScripts.onLoad);
				obj.onLoadScriptRan = true;

				// Play sound at the same time as when onLoad script runs
				if(audioContext && obj.audioBuffer) {
					playSound(obj.audioBuffer);
				}
			}

			// Recursively run all onLoads
			if(obj.isSymbol) {
				WickSharedUtils.forEachActiveChildObject(obj, function(subObj) {
					runOnLoadScript(subObj);
				});
			}

		}

	}

	var runUpdateScript = function (obj) {

		// Run update script
		if(obj && !obj.isRoot && obj.wickScripts) {
			evalScript(obj, obj.wickScripts.onUpdate);
		}

		// Recursively run all updates
		if(obj.isSymbol) {
			WickSharedUtils.forEachActiveChildObject(obj, function(subObj) {
				runUpdateScript(subObj);
			});
		}

	}

	var runOnClickScript = function (obj) {

		if(obj.wickScripts.onClick) {
			evalScript(obj, obj.wickScripts.onClick);
		}

	}

	var runKeyDownScript = function (obj) {

		if(obj.wickScripts.onKeyDown) {
			evalScript(obj, obj.wickScripts.onKeyDown);
		}

	}

	var evalScript = function (obj, script) {

		// Setup builtin wick scripting methods and objects
		var play          = function ()      { obj.parentObj.play(); }
		var stop          = function ()      { obj.parentObj.stop(); }
		var gotoAndPlay   = function (frame) { obj.parentObj.gotoAndPlay(frame); }
		var gotoAndStop   = function (frame) { obj.parentObj.gotoAndStop(frame); }
		var gotoNextFrame = function ()      { obj.parentObj.gotoNextFrame(); }
		var gotoPrevFrame = function ()      { obj.parentObj.gotoPrevFrame(); }

		// Setup wickobject reference variables
		var root = project.rootObject;
		var parent = obj.parentObj;
		WickSharedUtils.forEachChildObject(obj.parentObj, function(subObj) {
			window[subObj.name] = subObj;
		});

		// Set x,y vars so user doesn't have to use top/left
		obj.x = obj.left;
		obj.y = obj.top;

		for(var i = 0; i < 100; i++) { // !!! why plseae dont do this
			script = script.replace("this.","obj.");
		}
		eval(script);

		// Update top/left ... Note that this will squash top and left, so user can't use those!!
		obj.left = obj.x;
		obj.top = obj.y;

		// Get rid of wickobject reference variables
		WickSharedUtils.forEachChildObject(obj.parentObj, function(subObj) {
			window[subObj.name] = undefined;
		});

	}

	var advanceTimeline = function (obj) {

		// Advance timeline for this object
		if(obj.isPlaying && obj.frames.length > 1) {
			/* Left the frame, all child objects are unloaded, make sure 
			   they run onLoad again next time we come back to this frame */
			WickSharedUtils.forEachActiveChildObject(obj, function(child) {
				child.onLoadScriptRan = false;
			});

			// Advance timeline one frame
			obj.currentFrame++;
			if(obj.currentFrame == obj.frames.length) {
				obj.currentFrame = 0;
			}
		}

		// Recusively advance timelines of all children
		if(obj.isSymbol) {
			WickSharedUtils.forEachActiveChildObject(obj, function(subObj) {
				if(subObj.isSymbol) {
					advanceTimeline(subObj);
				}
			});
		}

	}

/*****************************
	Draw
*****************************/

	var draw = function () {

		// Calculate centered project window position
		var projectPositionX = (window.innerWidth - project.resolution.x) / 2;
		var projectPositionY = (window.innerHeight - project.resolution.y) / 2;

		// Scale to fit window
		context.save();
		context.translate(projectFitScreenTranslate.x, projectFitScreenTranslate.y);
		context.scale(projectFitScreenScale, projectFitScreenScale);

		// Clear canvas
		context.clearRect(0, 0, canvas.width, canvas.height);

		context.fillStyle = project.backgroundColor;
		context.fillRect(
			projectPositionX, 
			projectPositionY, 
			project.resolution.x, 
			project.resolution.y);

		// Draw root object, this will recursively draw every object!
		context.save();
			context.globalAlpha = 1.0;
			if(!project.fitScreen) {
				context.translate(projectPositionX, projectPositionY);
			}
			drawWickObject(project.rootObject);
		context.restore();

		context.restore();

		// Draw border around project (to hide offscreen objects)
		if(!project.fitScreen) {
			context.fillStyle = "#000000";
			context.fillRect( // top side
				0, 0, 
				window.innerWidth, projectPositionY);
			context.fillRect( // bottom side
				0, projectPositionY + project.resolution.y, 
				window.innerWidth, projectPositionY);
			context.fillRect( // left side
				0, 0, 
				projectPositionX, window.innerHeight);
			context.fillRect( // right side
				projectPositionX+project.resolution.x, 0, 
				projectPositionX, window.innerHeight);
		}
		
		// Draw FPS counter
		context.fillStyle = "White";
		context.font      = "normal 14pt Arial";
		context.fillText(fps.getFPS() + " FPS", canvas.width-80, 29);

	}

	var doTransformationsForObject = function (wickObject) {

		// Translation transforms
		context.translate(wickObject.left, wickObject.top);

		// Rotation transforms
		context.translate(wickObject.width/2, wickObject.height/2);
		context.rotate(wickObject.angle/360*2*3.14159);
		context.translate(-wickObject.width/2, -wickObject.height/2);

		// Scale transforms
		context.scale(wickObject.scaleX, wickObject.scaleY);

		// Horizontal/vertical flip transforms
		if(wickObject.flipX) {
			canvasContext.translate(wickObject.width, 0);
			canvasContext.scale(-1, 1);
		}
		if(wickObject.flipY) {
			canvasContext.translate(wickObject.width, 0);
			canvasContext.scale(-1, 1);
		}

	}

	var drawWickObject = function (obj) {

		var oldOpacity = context.globalAlpha;
		context.globalAlpha = oldOpacity*obj.opacity;

		context.save();
		doTransformationsForObject(obj);

		if(obj.isSymbol) {

			// Recursively draw all sub objects.
			WickSharedUtils.forEachActiveChildObject(obj, function(subObj) {
				drawWickObject(subObj);
			});

		} else {

			// Draw the content of this static object.
			if(obj.imageData) {

				context.drawImage(obj.image, 0, 0);

			} else if(obj.fontData) {

				context.save();
					context.translate(0, obj.fontData.fontSize);
					context.fillStyle = obj.fontData.fill;
					context.font      = "normal " + obj.fontData.fontSize + "px " + obj.fontData.fontFamily;
					context.fillText(obj.fontData.text, 0, 0);
				context.restore();

			}
		}

		context.restore();

		context.globalAlpha = oldOpacity;

	}

	return wickPlayer;

})();</script>
<script>WickPlayer.runProject('{"rootObject":{"parentObject":null,"wickScripts":{"onLoad":"//%20onLoad%0A//%20This%20script%20runs%20once%20when%20this%20object%20enters%20the%20scene.%0A","onClick":"//%20onClick%0A//%20This%20script%20runs%20when%20this%20object%20is%20clicked%20on.%0A","onUpdate":"//%20onUpdate%0A//%20This%20script%20runs%20repeatedly%20whenever%20this%20object%20is%20in%20the%20scene.%0A","onKeyDown":"//%20onKeyDown%0A//%20This%20script%20runs%20whenever%20a%20key%20is%20pressed.%0A"},"isSymbol":true,"currentFrame":0,"frames":[{"wickObjects":[{"parentObject":null,"wickScripts":{"onLoad":"//%20onLoad%0A//%20This%20script%20runs%20once%20when%20this%20object%20enters%20the%20scene.%0A","onClick":"//%20onClick%0A//%20This%20script%20runs%20when%20this%20object%20is%20clicked%20on.%0A","onUpdate":"//%20onUpdate%0A//%20This%20script%20runs%20repeatedly%20whenever%20this%20object%20is%20in%20the%20scene.%0A","onKeyDown":"//%20onKeyDown%0A//%20This%20script%20runs%20whenever%20a%20key%20is%20pressed.%0A"},"fontData":{"cursorColor":"#333","cursorDelay":1000,"cursorWidth":2,"editable":true,"fontFamily":"arial","fontSize":40,"fontStyle":"normal","fontWeight":"normal","hasBorders":false,"lineHeight":1.16,"fill":"#000000","textAlign":"left","textDecoration":"","text":"REFRESH%20THE%20PAGE%20FOR%20"},"isSymbol":false,"currentFrame":null,"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"left":69,"top":168,"width":511.171875,"height":52.431999999999995},{"parentObject":null,"wickScripts":{"onLoad":"//%20onLoad%0A//%20This%20script%20runs%20once%20when%20this%20object%20enters%20the%20scene.%0A","onClick":"//%20onClick%0A//%20This%20script%20runs%20when%20this%20object%20is%20clicked%20on.%0A","onUpdate":"//%20onUpdate%0A//%20This%20script%20runs%20repeatedly%20whenever%20this%20object%20is%20in%20the%20scene.%0A","onKeyDown":"//%20onKeyDown%0A//%20This%20script%20runs%20whenever%20a%20key%20is%20pressed.%0A"},"fontData":{"cursorColor":"#333","cursorDelay":1000,"cursorWidth":2,"editable":true,"fontFamily":"arial","fontSize":"96","fontStyle":"normal","fontWeight":"normal","hasBorders":false,"lineHeight":1.16,"fill":"#000000","textAlign":"left","textDecoration":"","text":"MORE%20BEES"},"isSymbol":false,"currentFrame":null,"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"left":40,"top":214.00000000000006,"width":570.796875,"height":125.83679999999997},{"parentObject":null,"wickScripts":{"onLoad":"//%20onLoad%0A//%20This%20script%20runs%20once%20when%20this%20object%20enters%20the%20scene.%0Avar%20nBees%20=%20localStorage.getItem(%22nBees%22);%0A%0Aif(!nBees)%20%7B%0A%20%20%20%20nBees%20=%201;%0A%7D%0A%0Aalert(%22There%20are%20%22%20+%20nBees%20+%20%22%20bees!!!!%22);%0A%0AnBees%20*=%2010;%0A%0AlocalStorage.setItem(%22nBees%22,%20nBees)","onClick":"//%20onClick%0A//%20This%20script%20runs%20when%20this%20object%20is%20clicked%20on.%0A","onUpdate":"//%20onUpdate%0A//%20This%20script%20runs%20repeatedly%20whenever%20this%20object%20is%20in%20the%20scene.%0A","onKeyDown":"//%20onKeyDown%0A//%20This%20script%20runs%20whenever%20a%20key%20is%20pressed.%0A"},"imageData":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAAAICAYAAACMPKELAAAAn0lEQVRYR+3YwQ2CQBBG4TcVSCl2gnSAFWgnagd0wNIBJViKVjAGEq+akL3x9rjJTDJfZi5/AEz9dEnyBByBZvnzKaDAT4EXMAcxt0P7iLEfr0HcRFNAgW0CSZ6j9CW3lVulgAJfAQ/JXVCggoCHVAHRFgp4SO6AAhUEDBsqINpi3wJr2LAQLMkdsMbfQRz2zeL0CvwXSPINPIHSDd39A01GJ0EokT+bAAAAAElFTkSuQmCC","isSymbol":false,"currentFrame":null,"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"width":210,"height":8,"left":275.25,"top":577}],"breakpoint":false,"frameLength":1,"tweenPoints":[]}],"isRoot":true,"left":0,"top":0},"resolution":{"x":650,"y":500},"backgroundColor":"#FFFFFF","framerate":12,"fitScreen":false}');</script>
